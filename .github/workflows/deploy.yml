name: Deploy Microservice  

on:  
  push:  
    branches:  
      - main  

jobs:  
  build:  
    runs-on: ubuntu-latest  
    steps:  
      - uses: actions/checkout@v3  
      
      # configuring AWS credentials

      - name: Configure AWS Credentials  
        uses: aws-actions/configure-aws-credentials@v1  
        with:  
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}  
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}  
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
    
      # Step 1: Bootstrap - Initialize and apply Terraform for S3 bucket and DynamoDB
      - name: Setup Terraform for Bootstrap
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: latest

      # Clear any existing local state to avoid conflicts
      - name: Clear Existing Terraform State for Bootstrap
        run: |
          cd bootstrap
          rm -rf .terraform terraform.tfstate terraform.tfstate.backup .terraform.lock.hcl || echo "No existing state files to clear"
          echo "Cleared existing Terraform state files"
          
      - name: Terraform Init for Bootstrap
        run: |
          cd bootstrap
          terraform init

      - name: Terraform Validate for Bootstrap
        run: |
          cd bootstrap
          terraform validate

      - name: Check and Import Existing Resources
        run: |
          cd bootstrap

           # Check and import S3 Bucket: cloudzenia-terraform-state
          BUCKET_EXISTS=$(aws s3api head-bucket --bucket cloudzenia-terraform-state --region ${{ secrets.AWS_REGION }} 2>/dev/null && echo "true" || echo "false")
          if [ "$BUCKET_EXISTS" = "true" ]; then
            echo "S3 Bucket cloudzenia-terraform-state already exists"
            terraform import aws_s3_bucket.terraform_state cloudzenia-terraform-state || echo "Failed to import S3 bucket, proceeding..."
          else
            echo "S3 Bucket cloudzenia-terraform-state does not exist, will create it."
          fi
          
          # Check and import IAM Policy: cloudzenia-s3-access
          POLICY_ARN_S3=$(aws iam list-policies --query "Policies[?PolicyName=='cloudzenia-s3-access'].Arn" --output text --region ${{ secrets.AWS_REGION }} 2>/dev/null || echo "")
          if [ -n "$POLICY_ARN_S3" ]; then
            echo "IAM Policy cloudzenia-s3-access already exists with ARN: $POLICY_ARN_S3"
            terraform import aws_iam_policy.s3_access $POLICY_ARN_S3 || echo "Failed to import IAM policy, proceeding..."
          else
            echo "IAM Policy cloudzenia-s3-access does not exist, will create it."
          fi

          # Check and import IAM Policy: cloudzenia-terraform-state-access
          POLICY_ARN_STATE=$(aws iam list-policies --query "Policies[?PolicyName=='cloudzenia-terraform-state-access'].Arn" --output text --region ${{ secrets.AWS_REGION }} 2>/dev/null || echo "")
          if [ -n "$POLICY_ARN_STATE" ]; then
            echo "IAM Policy cloudzenia-terraform-state-access already exists with ARN: $POLICY_ARN_STATE"
            terraform import aws_iam_policy.terraform_state $POLICY_ARN_STATE || echo "Failed to import IAM policy, proceeding..."
          else
            echo "IAM Policy cloudzenia-terraform-state-access does not exist, will create it."
          fi

          # Check and import DynamoDB Table: cloudzenia-terraform-locks
          TABLE_EXISTS=$(aws dynamodb describe-table --table-name cloudzenia-terraform-locks --region ${{ secrets.AWS_REGION }} --query "Table.TableName" --output text 2>/dev/null || echo "")
          if [ -n "$TABLE_EXISTS" ]; then
            echo "DynamoDB Table cloudzenia-terraform-locks already exists"
            terraform import aws_dynamodb_table.terraform_locks cloudzenia-terraform-locks || echo "Failed to import DynamoDB table, proceeding..."
          else
            echo "DynamoDB Table cloudzenia-terraform-locks does not exist, will create it."
          fi

          sleep 5
        # Sleep to ensure state changes propagate
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
      - name: Verify and Refresh Terraform State
        run: |
          cd bootstrap

          # Verify if S3 bucket is in the state
          if terraform state list | grep -q "aws_s3_bucket.terraform_state"; then
            echo "S3 Bucket cloudzenia-terraform-state is in the Terraform state"
          else
            echo "S3 Bucket cloudzenia-terraform-state is NOT in the Terraform state, attempting re-import..."
            terraform import aws_s3_bucket.terraform_state cloudzenia-terraform-state || echo "Failed to re-import S3 bucket, proceeding anyway as bucket exists..."
          fi

          # Refresh Terraform state to ensure consistency
          terraform refresh || echo "Failed to refresh Terraform state, proceeding..."
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          

      - name: Terraform Apply for Bootstrap (S3 and DynamoDB)
        run: |
          cd bootstrap
          terraform apply --auto-approve
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}

      # Step 2: Build and Push Microservice Image to ECR
      - name: Login to Amazon ECR  
        uses: aws-actions/amazon-ecr-login@v1  
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Build, tag, and push Microservice image to Amazon ECR  
        run: |  
          cd microservice  
          docker build -t microservice:latest .  
          docker tag microservice:latest ${{ secrets.ECR_REGISTRY }}/microservice:latest  
          docker push ${{ secrets.ECR_REGISTRY }}/microservice:latest  
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}

      # Step 3: check and manage Secrets Manager Secrets
      - name: Check and Manage Secrets Manager Secret
        run: |
          SECRET_NAME="wordpress-db-password"
          if aws secretsmanager describe-secret --secret-id $SECRET_NAME --region ${{ secrets.AWS_REGION }} 2>/dev/null; then
            echo "Secret $SECRET_NAME exists, checking deletion status..."
            if aws secretsmanager describe-secret --secret-id $SECRET_NAME --region ${{ secrets.AWS_REGION }} | grep -q '"DeletedDate"'; then
              echo "Secret is scheduled for deletion, force deleting..."
              aws secretsmanager delete-secret --secret-id $SECRET_NAME --force-delete-without-recovery --region ${{ secrets.AWS_REGION }}
              echo "Secret $SECRET_NAME force deleted."
              sleep 10  # Wait for deletion to propagate
            else
              echo "Secret is not scheduled for deletion, deleting now..."
              aws secretsmanager delete-secret --secret-id $SECRET_NAME --force-delete-without-recovery --region ${{ secrets.AWS_REGION }}
              echo "Secret $SECRET_NAME deleted."
              sleep 10  # Wait for deletion to propagate
            fi
            echo "Recreating secret $SECRET_NAME..."
            aws secretsmanager create-secret --name $SECRET_NAME --secret-string '{"password":"${{ secrets.TF_VAR_db_password }}"}' --region ${{ secrets.AWS_REGION }}
          else
            echo "Secret $SECRET_NAME does not exist, creating..."
            aws secretsmanager create-secret --name $SECRET_NAME --secret-string '{"password":"${{ secrets.TF_VAR_db_password }}"}' --region ${{ secrets.AWS_REGION }}
          fi
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
     
      # step 4: Setup terraform for Infrastructure
      - name: Setup Terraform  
        uses: hashicorp/setup-terraform@v2  
        with:  
          terraform_version: latest
          terraform_wrapper: false  # Allows capturing outputs
      
      - name: Terraform Init for Infrastructure
        run: |
          cd terraform
          terraform init

      - name: Terraform Validate for Infrastructure
        run: |
          cd terraform
          terraform validate
          
      - name: Terraform Plan for Infrastructure
        id: plan
        run: |
          cd terraform
          terraform plan -no-color -input=false -out=tfplan
          echo "changes=$(terraform show -no-color tfplan | grep -q 'No changes.' && echo 'false' || echo 'true')" >> $GITHUB_OUTPUT
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_hosted_zone_id: ${{ secrets.TF_VAR_hosted_zone_id }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}

      - name: Terraform Apply for Infrastructure
        id: apply
        if: steps.plan.outputs.changes == 'true'
        run: |
          cd terraform
          terraform apply -no-color -input=false -auto-approve
          # Capture output variables for URLs
          echo "wordpress_url=$(terraform output -raw wordpress_url)" >> $GITHUB_OUTPUT
          echo "microservice_url=$(terraform output -raw microservice_url)" >> $GITHUB_OUTPUT
          echo "docs_url=$(terraform output -raw docs_url)" >> $GITHUB_OUTPUT
          echo "ec2_instance1_url=$(terraform output -raw ec2_instance1_url)" >> $GITHUB_OUTPUT
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_hosted_zone_id: ${{ secrets.TF_VAR_hosted_zone_id }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}


      # Step 5: Upload Docs to S3 Bucket
      - name: Get S3 Bucket Name
        id: get-s3-bucket
        run: |
         cd terraform
         echo "bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
      - name: Upload Docs to S3
        run: |
          aws s3 sync ./docs/ s3://${{ steps.get-s3-bucket.outputs.bucket_name }}/ --region ${{ secrets.AWS_REGION }}

      # Step 6: Force ECS Service Deployment
      - name: Deploy to ECS (WordPress Service)
        run: |
          aws ecs update-service --cluster cloudzenia-ecs --service wordpress-service --force-new-deployment --region ${{ secrets.AWS_REGION }}
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Deploy to ECS (Microservice Service)
        run: |
          aws ecs update-service --cluster cloudzenia-ecs --service microservice-service --force-new-deployment --region ${{ secrets.AWS_REGION }}
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
      
      # Step 7: Print Accessible URLs
      - name: Print Accessible URLs
        if: steps.plan.outputs.changes == 'true'
        run: |
          echo "WordPress URL: https://${{ steps.apply.outputs.wordpress_url }}"
          echo "Microservice URL: https://${{ steps.apply.outputs.microservice_url }}"
          echo "Docs URL: http://${{ steps.apply.outputs.docs_url }}"
          echo "EC2 Instance 1 URL: https://${{ steps.apply.outputs.ec2_instance1_url }}"
